# ç¬¬äºŒé˜¶æ®µï¼šä»£ç ç»“æ„åˆ†æ

## 2.1 ä¸»è¦æºç ç›®å½•è¯¦è§£

### å®Œæ•´ç›®å½•æ ‘

```
falco_study/
â”œâ”€â”€ driver/                          # å†…æ ¸æ¨¡å—é©±åŠ¨æ ¸å¿ƒä»£ç 
â”‚   â”œâ”€â”€ main.c (82 KB)              # æ¨¡å—åˆå§‹åŒ–ã€è®¾å¤‡ç®¡ç†ã€tracepointæ³¨å†Œ
â”‚   â”œâ”€â”€ ppm_events.c (44 KB)        # äº‹ä»¶å¤„ç†é€»è¾‘
â”‚   â”œâ”€â”€ ppm_fillers.c (236 KB)      # æ•°æ®å¡«å……å™¨ï¼ˆæœ€æ ¸å¿ƒçš„æ–‡ä»¶ï¼‰
â”‚   â”œâ”€â”€ ppm_ringbuffer.h            # ç¯å½¢ç¼“å†²åŒºæ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ ppm.h                       # æ ¸å¿ƒæ•°æ®ç»“æ„å®šä¹‰
â”‚   â”œâ”€â”€ ppm_events_public.h (83 KB) # å…¬å…±äº‹ä»¶å®šä¹‰å’Œå¸¸é‡
â”‚   â”‚
â”‚   â”œâ”€â”€ event_table.c (173 KB)      # äº‹ä»¶è·¯ç”±è¡¨ï¼ˆç³»ç»Ÿè°ƒç”¨ â†’ äº‹ä»¶ç±»å‹ï¼‰
â”‚   â”œâ”€â”€ fillers_table.c (14 KB)     # Filler å‡½æ•°è°ƒåº¦è¡¨
â”‚   â”œâ”€â”€ flags_table.c (30 KB)       # æ ‡å¿—ä½è½¬æ¢è¡¨
â”‚   â”‚
â”‚   â”œâ”€â”€ syscall_compat_*.h          # 6ç§æ¶æ„çš„ç³»ç»Ÿè°ƒç”¨å…¼å®¹å±‚
â”‚   â”‚   â”œâ”€â”€ x86_64.h (21 KB)       # Intel/AMD 64ä½
â”‚   â”‚   â”œâ”€â”€ aarch64.h (19 KB)      # ARM 64ä½
â”‚   â”‚   â”œâ”€â”€ s390x.h (22 KB)        # IBM å¤§å‹æœº
â”‚   â”‚   â”œâ”€â”€ ppc64le.h (23 KB)      # PowerPC 64ä½å°ç«¯
â”‚   â”‚   â”œâ”€â”€ riscv64.h (19 KB)      # RISC-V 64ä½
â”‚   â”‚   â””â”€â”€ loongarch64.h (19 KB)  # é¾™èŠ¯æ¶æ„
â”‚   â”‚
â”‚   â”œâ”€â”€ bpf/                        # Legacy BPF é©±åŠ¨
â”‚   â”‚   â”œâ”€â”€ probe.c (11 KB)         # BPF ç¨‹åºå…¥å£ï¼ˆsys_enter/sys_exitï¼‰
â”‚   â”‚   â”œâ”€â”€ fillers.h (224 KB)      # BPF ç‰ˆæœ¬çš„æ•°æ®å¡«å……å™¨
â”‚   â”‚   â”œâ”€â”€ maps.h                  # BPF Map å®šä¹‰ï¼ˆç¼“å†²åŒºã€çŠ¶æ€è¡¨ï¼‰
â”‚   â”‚   â”œâ”€â”€ filler_helpers.h (47 KB)# è¾…åŠ©å‡½æ•°ï¼ˆå†…å­˜è®¿é—®ã€å­—ç¬¦ä¸²æ‹·è´ï¼‰
â”‚   â”‚   â”œâ”€â”€ plumbing_helpers.h (18 KB) # åº•å±‚å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ ring_helpers.h          # ç¯å½¢ç¼“å†²åŒºæ“ä½œ
â”‚   â”‚   â”œâ”€â”€ types.h                 # BPF ç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ bpf_helpers.h           # BPF Helper å‡½æ•°å°è£…
â”‚   â”‚   â””â”€â”€ configure/              # å†…æ ¸ç‰¹æ€§æ£€æµ‹
â”‚   â”‚
â”‚   â””â”€â”€ modern_bpf/                 # Modern BPF é©±åŠ¨
â”‚       â”œâ”€â”€ programs/
â”‚       â”‚   â”œâ”€â”€ attached/           # å§‹ç»ˆåŠ è½½çš„ç¨‹åº
â”‚       â”‚   â”‚   â””â”€â”€ dispatchers/    # è°ƒåº¦å™¨ç¨‹åº
â”‚       â”‚   â”‚       â”œâ”€â”€ syscall_exit.bpf.c  # ç³»ç»Ÿè°ƒç”¨é€€å‡ºè°ƒåº¦å™¨
â”‚       â”‚   â”‚       â””â”€â”€ signal_deliver.bpf.c # ä¿¡å·ä¼ é€’
â”‚       â”‚   â””â”€â”€ tail_called/        # å°¾è°ƒç”¨ç¨‹åº
â”‚       â”‚       â””â”€â”€ events/         # 60+ ç‹¬ç«‹ç³»ç»Ÿè°ƒç”¨å¤„ç†ç¨‹åº
â”‚       â”‚           â””â”€â”€ syscall_dispatched_events/
â”‚       â”‚               â”œâ”€â”€ open.bpf.c      # open ç³»ç»Ÿè°ƒç”¨
â”‚       â”‚               â”œâ”€â”€ openat.bpf.c    # openat ç³»ç»Ÿè°ƒç”¨
â”‚       â”‚               â”œâ”€â”€ openat2.bpf.c   # openat2 ç³»ç»Ÿè°ƒç”¨
â”‚       â”‚               â”œâ”€â”€ read.bpf.c      # read ç³»ç»Ÿè°ƒç”¨
â”‚       â”‚               â”œâ”€â”€ write.bpf.c     # write ç³»ç»Ÿè°ƒç”¨
â”‚       â”‚               â”œâ”€â”€ connect.bpf.c   # connect ç½‘ç»œè¿æ¥
â”‚       â”‚               â”œâ”€â”€ accept.bpf.c    # accept æ¥å—è¿æ¥
â”‚       â”‚               â”œâ”€â”€ bind.bpf.c      # bind ç»‘å®šç«¯å£
â”‚       â”‚               â”œâ”€â”€ execve.bpf.c    # execve æ‰§è¡Œç¨‹åº
â”‚       â”‚               â”œâ”€â”€ clone.bpf.c     # clone åˆ›å»ºè¿›ç¨‹
â”‚       â”‚               â””â”€â”€ ...             # æ›´å¤šç³»ç»Ÿè°ƒç”¨
â”‚       â”‚
â”‚       â”œâ”€â”€ helpers/                # å¯å¤ç”¨è¾…åŠ©å‡½æ•°åº“
â”‚       â”‚   â”œâ”€â”€ base/              # åŸºç¡€å‡½æ•°
â”‚       â”‚   â”‚   â”œâ”€â”€ common.h       # é€šç”¨å·¥å…·
â”‚       â”‚   â”‚   â”œâ”€â”€ maps_getters.h # Map è®¿é—®å™¨
â”‚       â”‚   â”‚   â”œâ”€â”€ push_data.h    # æ•°æ®æ¨é€
â”‚       â”‚   â”‚   â”œâ”€â”€ read_from_task.h # è¿›ç¨‹å†…å­˜è¯»å–
â”‚       â”‚   â”‚   â””â”€â”€ stats.h        # ç»Ÿè®¡ä¿¡æ¯
â”‚       â”‚   â”œâ”€â”€ extract/           # æ•°æ®æå–
â”‚       â”‚   â”‚   â”œâ”€â”€ extract_from_kernel.h  # å†…æ ¸æ•°æ®æå–
â”‚       â”‚   â”‚   â””â”€â”€ ...
â”‚       â”‚   â”œâ”€â”€ store/             # æ•°æ®å­˜å‚¨
â”‚       â”‚   â”‚   â””â”€â”€ store_event_to_ringbuf.h
â”‚       â”‚   â””â”€â”€ interfaces/        # æ¥å£å®šä¹‰
â”‚       â”‚       â”œâ”€â”€ fixed_size_event.h     # å›ºå®šå¤§å°äº‹ä»¶
â”‚       â”‚       â””â”€â”€ variable_size_event.h  # å¯å˜å¤§å°äº‹ä»¶
â”‚       â”‚
â”‚       â”œâ”€â”€ maps/                  # å…±äº« BPF Map
â”‚       â”‚   â””â”€â”€ map_definitions.h
â”‚       â”‚
â”‚       â”œâ”€â”€ definitions/           # æ¶æ„ç›¸å…³å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ x86_64/           # x86-64 å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ aarch64/          # ARM64 å®šä¹‰
â”‚       â”‚   â”œâ”€â”€ s390x/            # s390x å®šä¹‰
â”‚       â”‚   â””â”€â”€ ppc64le/          # PowerPC å®šä¹‰
â”‚       â”‚
â”‚       â””â”€â”€ shared_definitions/   # å…±äº«å®šä¹‰
â”‚
â”œâ”€â”€ userspace/libscap/             # ç”¨æˆ·æ€ç³»ç»Ÿæ•è·åº“
â”‚   â”œâ”€â”€ scap.h (37 KB)            # ä¸»æ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ scap.c                    # ä¸»æ¥å£å®ç°
â”‚   â”‚
â”‚   â”œâ”€â”€ engine/                   # é©±åŠ¨å¼•æ“æŠ½è±¡å±‚
â”‚   â”‚   â”œâ”€â”€ api/                  # å¼•æ“ API å®šä¹‰
â”‚   â”‚   â”‚   â””â”€â”€ engines.h         # å¼•æ“è™šå‡½æ•°è¡¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ kmod/                 # å†…æ ¸æ¨¡å—å¼•æ“
â”‚   â”‚   â”‚   â”œâ”€â”€ scap_kmod.c       # kmod å®ç°
â”‚   â”‚   â”‚   â””â”€â”€ kmod.h            # kmod æ¥å£
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ bpf/                  # BPF å¼•æ“
â”‚   â”‚   â”‚   â”œâ”€â”€ scap_bpf.c        # BPF å®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ attached_prog.c   # BPF ç¨‹åºåŠ è½½
â”‚   â”‚   â”‚   â””â”€â”€ bpf.h             # BPF æ¥å£
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ modern_bpf/           # Modern BPF å¼•æ“
â”‚   â”‚       â”œâ”€â”€ scap_modern_bpf.c # Modern BPF å®ç°
â”‚   â”‚       â””â”€â”€ modern_bpf.h      # Modern BPF æ¥å£
â”‚   â”‚
â”‚   â””â”€â”€ ringbuffer/
â”‚       â””â”€â”€ ringbuffer.h          # ç¯å½¢ç¼“å†²åŒºè¯»å–é€»è¾‘
â”‚
â””â”€â”€ cmake/modules/                 # æ„å»ºç³»ç»Ÿ
    â”œâ”€â”€ driver.cmake              # é©±åŠ¨ç¼–è¯‘é…ç½®
    â”œâ”€â”€ falcosecurity-libs.cmake  # ä¾èµ–åº“ç®¡ç†
    â””â”€â”€ driver-repo/              # é©±åŠ¨æ„å»ºè„šæœ¬
```

### æ ¸å¿ƒæ–‡ä»¶è¯´æ˜

#### driver/main.c (82 KB)
**ä½œç”¨ï¼š** å†…æ ¸æ¨¡å—çš„ä¸»å…¥å£ï¼Œè´Ÿè´£æ¨¡å—çš„åˆå§‹åŒ–ã€è®¾å¤‡ç®¡ç†å’Œ tracepoint æ³¨å†Œã€‚

**å…³é”®å‡½æ•°ï¼š**
- `ppm_init()` - æ¨¡å—åˆå§‹åŒ–
- `ppm_exit()` - æ¨¡å—æ¸…ç†
- `syscall_enter_probe()` - ç³»ç»Ÿè°ƒç”¨è¿›å…¥é’©å­
- `syscall_exit_probe()` - ç³»ç»Ÿè°ƒç”¨é€€å‡ºé’©å­
- `init_ring_buffer()` - åˆå§‹åŒ–ç¯å½¢ç¼“å†²åŒº

#### driver/ppm_fillers.c (236 KB)
**ä½œç”¨ï¼š** **æœ€æ ¸å¿ƒçš„æ–‡ä»¶**ï¼ŒåŒ…å«æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨çš„æ•°æ®å¡«å……å™¨ï¼ˆfillerï¼‰å‡½æ•°ã€‚

**å…³é”®å‡½æ•°ç¤ºä¾‹ï¼š**
- `f_sys_renameat2_x()` - rename ç³»ç»Ÿè°ƒç”¨é€€å‡ºå¤„ç†
- `f_sys_socket_x()` - socket åˆ›å»ºé€€å‡ºå¤„ç†
- `f_sys_connect_x()` - connect è¿æ¥é€€å‡ºå¤„ç†
- `val_to_ring()` - å†™å…¥æ•°æ®åˆ°ç¯å½¢ç¼“å†²åŒº

#### driver/event_table.c (173 KB)
**ä½œç”¨ï¼š** ç³»ç»Ÿè°ƒç”¨äº‹ä»¶æ˜ å°„è¡¨ï¼Œå®šä¹‰æ¯ä¸ªç³»ç»Ÿè°ƒç”¨å¯¹åº”çš„äº‹ä»¶ç±»å‹ã€‚

**æ•°æ®ç»“æ„ï¼š**
```c
const struct syscall_evt_pair g_syscall_table[SYSCALL_TABLE_SIZE] = {
    [__NR_open] = {
        .enter_event_type = PPME_SYSCALL_OPEN_E,
        .exit_event_type = PPME_SYSCALL_OPEN_X,
        .flags = UF_USED | UF_ALWAYS_DROP,
    },
    // ... 350+ ç³»ç»Ÿè°ƒç”¨
};
```

---

## 2.2 å…³é”®æ•°æ®ç»“æ„è¯¦è§£

### ç»“æ„ 1ï¼šäº‹ä»¶å¤´ï¼ˆEvent Headerï¼‰

```c
// ä½ç½®ï¼šdriver/ppm_events_public.h

struct ppm_evt_hdr {
    uint64_t ts;         // æ—¶é—´æˆ³ï¼ˆçº³ç§’ï¼Œå•è°ƒæ—¶é’Ÿï¼‰
    uint64_t tid;        // çº¿ç¨‹ IDï¼ˆå†…æ ¸ tidï¼‰
    uint32_t len;        // äº‹ä»¶æ€»é•¿åº¦ï¼ˆåŒ…æ‹¬å¤´éƒ¨å’Œæ‰€æœ‰å‚æ•°ï¼‰
    uint16_t type;       // äº‹ä»¶ç±»å‹ï¼ˆPPME_SYSCALL_OPEN_X ç­‰ï¼‰
    uint32_t nparams;    // å‚æ•°ä¸ªæ•°
};

// å®é™…äº‹ä»¶ç¤ºä¾‹ï¼ˆopen ç³»ç»Ÿè°ƒç”¨ï¼‰ï¼š
// åç§»  å­—æ®µ         å€¼                    è¯´æ˜
// 0     ts          1705234567890123      2024-01-14 12:34:56.890123 UTC
// 8     tid         12345                 è¿›ç¨‹ PID
// 16    len         92                    æ€»é•¿åº¦ 92 å­—èŠ‚
// 20    type        PPME_SYSCALL_OPEN_X   open é€€å‡ºäº‹ä»¶
// 22    nparams     4                     4 ä¸ªå‚æ•°
// 26    [params]    ...                   å‚æ•°æ•°æ®å¼€å§‹
```

**äº‹ä»¶ç±»å‹æšä¸¾ï¼ˆéƒ¨åˆ†ï¼‰ï¼š**

```c
// ä½ç½®ï¼šdriver/ppm_events_public.h

typedef enum {
    PPME_GENERIC_E = 0,         // é€šç”¨è¿›å…¥äº‹ä»¶
    PPME_GENERIC_X = 1,         // é€šç”¨é€€å‡ºäº‹ä»¶

    // æ–‡ä»¶æ“ä½œ
    PPME_SYSCALL_OPEN_E = 2,
    PPME_SYSCALL_OPEN_X = 3,
    PPME_SYSCALL_CLOSE_E = 4,
    PPME_SYSCALL_CLOSE_X = 5,
    PPME_SYSCALL_READ_E = 6,
    PPME_SYSCALL_READ_X = 7,
    PPME_SYSCALL_WRITE_E = 8,
    PPME_SYSCALL_WRITE_X = 9,

    // è¿›ç¨‹ç®¡ç†
    PPME_SYSCALL_CLONE_20_E = 220,
    PPME_SYSCALL_CLONE_20_X = 221,
    PPME_SYSCALL_EXECVE_19_E = 293,
    PPME_SYSCALL_EXECVE_19_X = 294,

    // ç½‘ç»œæ“ä½œ
    PPME_SOCKET_CONNECT_E = 42,
    PPME_SOCKET_CONNECT_X = 43,
    PPME_SOCKET_ACCEPT_5_E = 232,
    PPME_SOCKET_ACCEPT_5_X = 233,

    // ... æ€»å…± 400+ äº‹ä»¶ç±»å‹

    PPM_EVENT_MAX = 497,        // æœ€å¤§äº‹ä»¶å·
} ppm_event_code;
```

### ç»“æ„ 2ï¼šç¯å½¢ç¼“å†²åŒºä¸Šä¸‹æ–‡

```c
// ä½ç½®ï¼šdriver/ppm.h

struct ppm_ring_buffer_context {
    bool cpu_online;                        // CPU æ˜¯å¦åœ¨çº¿
    bool open;                              // ç¼“å†²åŒºæ˜¯å¦å·²æ‰“å¼€
    struct ppm_ring_buffer_info *info;      // å…ƒæ•°æ®ï¼ˆhead/tail/è®¡æ•°å™¨ï¼‰
    char *buffer;                           // å®é™…æ•°æ®ç¼“å†²åŒºæŒ‡é’ˆ
    uint32_t nevents;                       // æœ¬ CPU äº‹ä»¶è®¡æ•°
    atomic_t preempt_count;                 // æŠ¢å è®¡æ•°ï¼ˆå¤šçº¿ç¨‹ä¿æŠ¤ï¼‰
    char *str_storage;                      // ä¸´æ—¶å­—ç¬¦ä¸²å­˜å‚¨ï¼ˆæ¯ CPU ç‹¬ç«‹ï¼‰
};

// å…ƒæ•°æ®ç»“æ„ï¼ˆä¸ç”¨æˆ·æ€å…±äº«ï¼‰
struct ppm_ring_buffer_info {
    volatile uint32_t head;                 // ç”Ÿäº§è€…å†™å…¥ä½ç½®
    volatile uint32_t tail;                 // æ¶ˆè´¹è€…è¯»å–ä½ç½®
    volatile uint64_t n_evts;               // äº‹ä»¶æ€»æ•°
    volatile uint64_t n_drops_buffer;       // ç¼“å†²åŒºæ»¡ä¸¢å¼ƒ
    volatile uint64_t n_drops_pf;           // é¡µé”™è¯¯ä¸¢å¼ƒ
    volatile uint64_t n_drops_bug;          // Bug å¯¼è‡´ä¸¢å¼ƒ
    volatile uint64_t n_preemptions;        // æŠ¢å æ¬¡æ•°
};
```

**ç¼“å†²åŒºçŠ¶æ€åˆ¤æ–­ï¼š**

```c
// åˆ¤æ–­ç¼“å†²åŒºæ˜¯å¦ä¸ºç©º
bool is_empty(struct ppm_ring_buffer_info *info) {
    return info->head == info->tail;
}

// åˆ¤æ–­ç¼“å†²åŒºæ˜¯å¦å·²æ»¡
bool is_full(struct ppm_ring_buffer_info *info, uint32_t size) {
    uint32_t available;
    if (info->head >= info->tail) {
        available = size - info->head + info->tail;
    } else {
        available = info->tail - info->head;
    }
    return available < MIN_EVENT_SIZE;  // å°äºæœ€å°äº‹ä»¶å¤§å°å³è§†ä¸ºæ»¡
}
```

### ç»“æ„ 3ï¼šäº‹ä»¶å¡«å……å™¨å‚æ•°

```c
// ä½ç½®ï¼šdriver/ppm_events.h

struct event_filler_arguments {
    ppm_consumer_t *consumer;       // æ¶ˆè´¹è€…ä¸Šä¸‹æ–‡
    char *buffer;                   // è¾“å‡ºç¼“å†²åŒº
    uint32_t buffer_size;           // å¯ç”¨ç©ºé—´
    uint32_t syscall_id;            // ç³»ç»Ÿè°ƒç”¨å·ï¼ˆ__NR_open ç­‰ï¼‰

    struct pt_regs *regs;           // CPU å¯„å­˜å™¨ï¼ˆç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼‰
    unsigned long args[6];          // æå–åçš„å‚æ•°ï¼ˆæœ€å¤š6ä¸ªï¼‰

    bool compat;                    // 32ä½å…¼å®¹æ¨¡å¼æ ‡å¿—
    long retval;                    // ç³»ç»Ÿè°ƒç”¨è¿”å›å€¼

    // ç‰¹å®šäº‹ä»¶çš„é¢å¤–å‚æ•°
    int fd;                         // æ–‡ä»¶æè¿°ç¬¦
    struct task_struct *sched_prev; // è°ƒåº¦äº‹ä»¶ï¼šå‰ä¸€ä»»åŠ¡
    struct task_struct *sched_next; // è°ƒåº¦äº‹ä»¶ï¼šä¸‹ä¸€ä»»åŠ¡

    // å†…éƒ¨çŠ¶æ€
    uint32_t curoff;                // å½“å‰å†™å…¥åç§»
    uint32_t nevents;               // äº‹ä»¶è®¡æ•°
    int enforce_snaplen;            // å¼ºåˆ¶æˆªæ–­æ ‡å¿—
    uint32_t snaplen;               // æˆªæ–­é•¿åº¦
};

// å¡«å……å™¨å‡½æ•°åŸå‹
typedef int (*filler_callback)(struct event_filler_arguments *args);
```

### ç»“æ„ 4ï¼šç³»ç»Ÿè°ƒç”¨äº‹ä»¶å¯¹

```c
// ä½ç½®ï¼šdriver/ppm_events_public.h

struct syscall_evt_pair {
    ppm_event_code enter_event_type;  // è¿›å…¥äº‹ä»¶ç±»å‹
    ppm_event_code exit_event_type;   // é€€å‡ºäº‹ä»¶ç±»å‹
    uint32_t flags;                   // æ ‡å¿—ä½
};

// æ ‡å¿—ä½å®šä¹‰
#define UF_NONE                 0       // æ— æ ‡å¿—
#define UF_USED                 (1 << 0) // éœ€è¦ enter äº‹ä»¶ï¼ˆTOCTOU ç¼“è§£ï¼‰
#define UF_NEVER_DROP           (1 << 1) // æ°¸ä¸ä¸¢å¼ƒï¼ˆå…³é”®äº‹ä»¶ï¼‰
#define UF_ALWAYS_DROP          (1 << 2) // æ€»æ˜¯ä¸¢å¼ƒï¼ˆé«˜é¢‘ä½ä»·å€¼ï¼‰
#define UF_SIMPLEDRIVER_KEEP    (1 << 3) // ç®€åŒ–é©±åŠ¨ä¿ç•™
#define UF_ATOMIC               (1 << 4) // åŸå­æ“ä½œï¼ˆç¦ç”¨æŠ¢å ï¼‰
```

### ç»“æ„ 5ï¼šFiller è¡¨é¡¹

```c
// ä½ç½®ï¼šdriver/ppm_fillers.h

struct ppm_event_entry {
    filler_callback filler_callback;  // å¡«å……å™¨å‡½æ•°æŒ‡é’ˆ
    enum ppm_filler_id filler_id;     // å¡«å……å™¨ ID
};

// å…¨å±€ Filler è¡¨
extern const struct ppm_event_entry g_ppm_events[PPM_EVENT_MAX];

// ç¤ºä¾‹ï¼šæŸ¥æ‰¾ open ç³»ç»Ÿè°ƒç”¨çš„ filler
const struct ppm_event_entry *entry = &g_ppm_events[PPME_SYSCALL_OPEN_X];
filler_callback filler = entry->filler_callback;
// filler æŒ‡å‘ f_sys_open_x() æˆ– f_sys_single_x()
```

---

## 2.3 äº‹ä»¶æ•è·çš„å®Œæ•´æµç¨‹

### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ç”¨æˆ·ç¨‹åºè°ƒç”¨ç³»ç»Ÿè°ƒç”¨                                           â”‚
â”‚     ä¾‹å¦‚ï¼šopen("/etc/passwd", O_RDONLY, 0644)                     â”‚
â”‚     ç¼–è¯‘ä¸ºï¼šmov $2, %rax; syscall                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ syscall æŒ‡ä»¤ â†’ é™·å…¥å†…æ ¸
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. å†…æ ¸ Tracepoint: trace_sys_enter                              â”‚
â”‚     ä½ç½®ï¼šarch/x86/include/asm/syscall.h                          â”‚
â”‚     - ä¿å­˜å¯„å­˜å™¨çŠ¶æ€ï¼ˆstruct pt_regsï¼‰                             â”‚
â”‚     - è°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„ probe å‡½æ•°                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Falco é©±åŠ¨é’©å­å‡½æ•°ï¼šsyscall_enter_probe                       â”‚
â”‚  ä»£ç ä½ç½®ï¼šdriver/main.c:syscall_enter_probe                      â”‚
â”‚                                                                    â”‚
â”‚  TRACEPOINT_PROBE(syscall_enter_probe,                            â”‚
â”‚                   struct pt_regs *regs, long id) {                â”‚
â”‚      // 3.1 æ£€æŸ¥ç³»ç»Ÿè°ƒç”¨æ˜¯å¦æ„Ÿå…´è¶£                                 â”‚
â”‚      const struct syscall_evt_pair *sc_evt =                      â”‚
â”‚          get_syscall_info(id);                                    â”‚
â”‚      if (!sc_evt || !(sc_evt->flags & UF_USED))                   â”‚
â”‚          return;  // å¤§éƒ¨åˆ†ç³»ç»Ÿè°ƒç”¨ä¸ç”Ÿæˆ enter äº‹ä»¶               â”‚
â”‚                                                                    â”‚
â”‚      // 3.2 ä¸º TOCTOU ç¼“è§£çš„ç³»ç»Ÿè°ƒç”¨è®°å½•è¿›å…¥å‚æ•°                   â”‚
â”‚      // open/connect ç­‰å¯èƒ½è¢«ç¯¡æ”¹çš„è°ƒç”¨                            â”‚
â”‚      struct event_data_t event_data;                              â”‚
â”‚      event_data.syscall_data.regs = regs;                         â”‚
â”‚      event_data.syscall_data.id = id;                             â”‚
â”‚                                                                    â”‚
â”‚      // 3.3 è®°å½•äº‹ä»¶                                               â”‚
â”‚      record_event_all_consumers(                                  â”‚
â”‚          sc_evt->enter_event_type,  // PPME_SYSCALL_OPEN_E        â”‚
â”‚          UF_NEVER_DROP,                                           â”‚
â”‚          &event_data,                                             â”‚
â”‚          KMOD_PROG_SYS_ENTER);                                    â”‚
â”‚  }                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. å†…æ ¸æ‰§è¡Œå®é™…ç³»ç»Ÿè°ƒç”¨                                           â”‚
â”‚     do_sys_open() â†’ do_filp_open() â†’ vfs_open() â†’ ...            â”‚
â”‚     â†’ æ‰“å¼€æ–‡ä»¶ï¼Œè¿”å›æ–‡ä»¶æè¿°ç¬¦ fd=3                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ è¿”å›ç”¨æˆ·æ€ä¹‹å‰
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. å†…æ ¸ Tracepoint: trace_sys_exit                               â”‚
â”‚     - æ•è·è¿”å›å€¼ï¼ˆfd=3 æˆ–é”™è¯¯ç ï¼‰                                  â”‚
â”‚     - è°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„ probe å‡½æ•°                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. Falco é©±åŠ¨é’©å­å‡½æ•°ï¼šsyscall_exit_probe                        â”‚
â”‚  ä»£ç ä½ç½®ï¼šdriver/main.c:syscall_exit_probe                       â”‚
â”‚                                                                    â”‚
â”‚  TRACEPOINT_PROBE(syscall_exit_probe,                             â”‚
â”‚                   struct pt_regs *regs, long ret) {               â”‚
â”‚      // 6.1 è·å–ç³»ç»Ÿè°ƒç”¨å·                                         â”‚
â”‚      long id = syscall_get_nr(current, regs);                     â”‚
â”‚      // id = __NR_open = 2 (x86_64)                               â”‚
â”‚                                                                    â”‚
â”‚      // 6.2 æŸ¥è¯¢ç³»ç»Ÿè°ƒç”¨ä¿¡æ¯                                       â”‚
â”‚      const struct syscall_evt_pair *sc_evt =                      â”‚
â”‚          get_syscall_info(id);                                    â”‚
â”‚      if (!is_syscall_interesting(id))                             â”‚
â”‚          return;  // è·³è¿‡ä¸æ„Ÿå…´è¶£çš„ç³»ç»Ÿè°ƒç”¨                        â”‚
â”‚                                                                    â”‚
â”‚      // 6.3 æå–ç³»ç»Ÿè°ƒç”¨å‚æ•°                                       â”‚
â”‚      unsigned long args[6];                                       â”‚
â”‚      syscall_get_arguments(current, regs, args);                  â”‚
â”‚      // args[0] = æŒ‡å‘ "/etc/passwd" çš„æŒ‡é’ˆ                        â”‚
â”‚      // args[1] = O_RDONLY                                        â”‚
â”‚      // args[2] = 0644                                            â”‚
â”‚                                                                    â”‚
â”‚      // 6.4 æ„å»º filler å‚æ•°ç»“æ„                                  â”‚
â”‚      struct event_filler_arguments fargs;                         â”‚
â”‚      fargs.syscall_id = id;                                       â”‚
â”‚      fargs.regs = regs;                                           â”‚
â”‚      fargs.retval = ret;  // fd=3                                 â”‚
â”‚      memcpy(fargs.args, args, sizeof(args));                      â”‚
â”‚                                                                    â”‚
â”‚      // 6.5 æŸ¥æ‰¾å¯¹åº”çš„ filler å‡½æ•°                                â”‚
â”‚      const struct ppm_event_entry *entry =                        â”‚
â”‚          &g_ppm_events[sc_evt->exit_event_type];                  â”‚
â”‚      filler_callback filler = entry->filler_callback;             â”‚
â”‚                                                                    â”‚
â”‚      // 6.6 è°ƒç”¨ filler å‡½æ•°å¡«å……äº‹ä»¶æ•°æ®                          â”‚
â”‚      filler(&fargs);  // è°ƒç”¨ f_sys_open_x()                      â”‚
â”‚  }                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  7. Filler å‡½æ•°ï¼šf_sys_renameat2_xï¼ˆå®é™…ä»£ç ç¤ºä¾‹ï¼‰                â”‚
â”‚  ä»£ç ä½ç½®ï¼šdriver/ppm_fillers.c:5031-5085                         â”‚
â”‚                                                                    â”‚
â”‚  int f_sys_renameat2_x(struct event_filler_arguments *args) {    â”‚
â”‚      unsigned long val;                                           â”‚
â”‚      int res;                                                     â”‚
â”‚      int32_t fd;                                                  â”‚
â”‚                                                                    â”‚
â”‚      // 7.1 å†™å…¥è¿”å›å€¼                                             â”‚
â”‚      int64_t retval = syscall_get_return_value(                   â”‚
â”‚          current, args->regs);                                    â”‚
â”‚      res = val_to_ring(args, retval, 0, false, 0);                â”‚
â”‚      CHECK_RES(res);  // æ£€æŸ¥æ˜¯å¦æˆåŠŸ                             â”‚
â”‚                                                                    â”‚
â”‚      // 7.2 å†™å…¥ olddirfd å‚æ•°                                     â”‚
â”‚      syscall_get_arguments_deprecated(args, 0, 1, &val);          â”‚
â”‚      fd = (int32_t)val;                                           â”‚
â”‚      if (fd == AT_FDCWD)                                          â”‚
â”‚          fd = PPM_AT_FDCWD;  // è§„èŒƒåŒ–ç‰¹æ®Šå€¼                      â”‚
â”‚      res = val_to_ring(args, (int64_t)fd, 0, false, 0);           â”‚
â”‚      CHECK_RES(res);                                              â”‚
â”‚                                                                    â”‚
â”‚      // 7.3 å†™å…¥ oldpath å­—ç¬¦ä¸²                                    â”‚
â”‚      syscall_get_arguments_deprecated(args, 1, 1, &val);          â”‚
â”‚      res = val_to_ring(args, val, 0, true, 0);                    â”‚
â”‚      // true = ä»ç”¨æˆ·ç©ºé—´æ‹·è´å­—ç¬¦ä¸²                                â”‚
â”‚      CHECK_RES(res);                                              â”‚
â”‚                                                                    â”‚
â”‚      // 7.4 å†™å…¥ newdirfd å‚æ•°                                     â”‚
â”‚      syscall_get_arguments_deprecated(args, 2, 1, &val);          â”‚
â”‚      fd = (int32_t)val;                                           â”‚
â”‚      if (fd == AT_FDCWD)                                          â”‚
â”‚          fd = PPM_AT_FDCWD;                                       â”‚
â”‚      res = val_to_ring(args, (int64_t)fd, 0, false, 0);           â”‚
â”‚      CHECK_RES(res);                                              â”‚
â”‚                                                                    â”‚
â”‚      // 7.5 å†™å…¥ newpath å­—ç¬¦ä¸²                                    â”‚
â”‚      syscall_get_arguments_deprecated(args, 3, 1, &val);          â”‚
â”‚      res = val_to_ring(args, val, 0, true, 0);                    â”‚
â”‚      CHECK_RES(res);                                              â”‚
â”‚                                                                    â”‚
â”‚      // 7.6 å†™å…¥ flags                                             â”‚
â”‚      syscall_get_arguments_deprecated(args, 4, 1, &val);          â”‚
â”‚      res = val_to_ring(args, val, 0, false, 0);                   â”‚
â”‚      CHECK_RES(res);                                              â”‚
â”‚                                                                    â”‚
â”‚      // 7.7 æ·»åŠ ç»“æŸæ ‡è®°                                           â”‚
â”‚      return add_sentinel(args);                                   â”‚
â”‚  }                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€ï¿½ï¿½ï¿½â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  8. æ ¸å¿ƒå‡½æ•°ï¼šval_to_ringï¼ˆå†™å…¥ç¯å½¢ç¼“å†²åŒºï¼‰                        â”‚
â”‚  ä»£ç ä½ç½®ï¼šdriver/ppm_events.c                                     â”‚
â”‚                                                                    â”‚
â”‚  static inline int val_to_ring(                                   â”‚
â”‚      struct event_filler_arguments *args,                         â”‚
â”‚      unsigned long val,      // è¦å†™å…¥çš„å€¼                        â”‚
â”‚      uint16_t val_len,       // å€¼çš„é•¿åº¦ï¼ˆ0=è‡ªåŠ¨ï¼‰                â”‚
â”‚      bool fromuser,          // æ˜¯å¦ä»ç”¨æˆ·ç©ºé—´æ‹·è´                â”‚
â”‚      uint8_t dyn_idx) {      // åŠ¨æ€å‚æ•°ç´¢å¼•                      â”‚
â”‚                                                                    â”‚
â”‚      ppm_consumer_t *consumer = args->consumer;                   â”‚
â”‚      struct ppm_ring_buffer_context *ring = consumer->ring;       â”‚
â”‚      char *buffer = args->buffer + args->curoff;                  â”‚
â”‚                                                                    â”‚
â”‚      if (fromuser) {                                              â”‚
â”‚          // ä»ç”¨æˆ·ç©ºé—´æ‹·è´å­—ç¬¦ä¸²                                   â”‚
â”‚          char *str_storage = ring->str_storage;                   â”‚
â”‚          long len = strncpy_from_user(                            â”‚
â”‚              str_storage, (void __user *)val, 4096);              â”‚
â”‚                                                                    â”‚
â”‚          if (len < 0) {                                           â”‚
â”‚              // æ‹·è´å¤±è´¥ï¼Œå†™å…¥ç©ºå­—ç¬¦ä¸²                             â”‚
â”‚              *(uint16_t*)buffer = 0;                              â”‚
â”‚              args->curoff += 2;                                   â”‚
â”‚              return PPM_SUCCESS;                                  â”‚
â”‚          }                                                         â”‚
â”‚                                                                    â”‚
â”‚          // å†™å…¥é•¿åº¦å‰ç¼€ï¼ˆ2å­—èŠ‚ï¼‰+ å­—ç¬¦ä¸²å†…å®¹                      â”‚
â”‚          *(uint16_t*)buffer = (uint16_t)len;                      â”‚
â”‚          memcpy(buffer + 2, str_storage, len);                    â”‚
â”‚          args->curoff += 2 + len;                                 â”‚
â”‚      } else {                                                     â”‚
â”‚          // ç›´æ¥å†™å…¥æ•´æ•°å€¼                                         â”‚
â”‚          if (val_len == 0)                                        â”‚
â”‚              val_len = sizeof(val);  // 8 å­—èŠ‚                    â”‚
â”‚          memcpy(buffer, &val, val_len);                           â”‚
â”‚          args->curoff += val_len;                                 â”‚
â”‚      }                                                             â”‚
â”‚                                                                    â”‚
â”‚      return PPM_SUCCESS;                                          â”‚
â”‚  }                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  9. å†™å…¥ç¯å½¢ç¼“å†²åŒºï¼ˆPer-CPUï¼‰                                      â”‚
â”‚  ä»£ç ä½ç½®ï¼šdriver/ppm_ringbuffer.h                                 â”‚
â”‚                                                                    â”‚
â”‚  ç¼“å†²åŒºå®é™…å¸ƒå±€ï¼ˆopen ç³»ç»Ÿè°ƒç”¨ç¤ºä¾‹ï¼‰ï¼š                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [Event Header 26B]                                         â”‚  â”‚
â”‚  â”‚   [0-7]   ts = 1705234567890123 (8B)                       â”‚  â”‚
â”‚  â”‚   [8-15]  tid = 12345 (8B)                                 â”‚  â”‚
â”‚  â”‚   [16-19] len = 92 (4B)                                    â”‚  â”‚
â”‚  â”‚   [20-21] type = PPME_SYSCALL_OPEN_X = 3 (2B)             â”‚  â”‚
â”‚  â”‚   [22-25] nparams = 4 (4B)                                 â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ [Param1: fd] (8B)                                          â”‚  â”‚
â”‚  â”‚   [26-33] \x03\x00\x00\x00\x00\x00\x00\x00  (fd=3, int64) â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ [Param2: filename] (15B)                                   â”‚  â”‚
â”‚  â”‚   [34-35] \x0d\x00  (len=13, uint16)                       â”‚  â”‚
â”‚  â”‚   [36-48] "/etc/passwd\0" (13B å­—ç¬¦ä¸²)                     â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ [Param3: flags] (4B)                                       â”‚  â”‚
â”‚  â”‚   [49-52] \x00\x00\x00\x00  (O_RDONLY=0, uint32)           â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ [Param4: mode] (4B)                                        â”‚  â”‚
â”‚  â”‚   [53-56] \xa4\x01\x00\x00  (0644, uint32)                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                    â”‚
â”‚  // åŸå­æ›´æ–° head æŒ‡é’ˆ                                             â”‚
â”‚  __sync_synchronize();  // å†…å­˜å±éšœ                               â”‚
â”‚  ring->info->head += 92;  // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªäº‹ä»¶ä½ç½®                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  10. ç”¨æˆ·æ€è¯»å–ï¼ˆlibscapï¼‰                                         â”‚
â”‚  ä»£ç ä½ç½®ï¼šlibscap/ringbuffer/ringbuffer.h:89-120                 â”‚
â”‚                                                                    â”‚
â”‚  // ä¸»äº‹ä»¶å¾ªç¯                                                     â”‚
â”‚  int scap_next(scap_t *handle, scap_evt **pevent) {              â”‚
â”‚      // 10.1 epoll ç­‰å¾…ä»»æ„ CPU ç¼“å†²åŒºæœ‰æ•°æ®                       â”‚
â”‚      struct epoll_event events[num_cpus];                         â”‚
â”‚      int nfds = epoll_wait(handle->epoll_fd,                      â”‚
â”‚                            events, num_cpus, timeout);            â”‚
â”‚                                                                    â”‚
â”‚      // 10.2 è¯»å–æœ‰æ•°æ®çš„ç¼“å†²åŒº                                    â”‚
â”‚      for (int i = 0; i < nfds; i++) {                            â”‚
â”‚          int cpu = events[i].data.u32;                            â”‚
â”‚          char *buf;                                               â”‚
â”‚          uint32_t len;                                            â”‚
â”‚                                                                    â”‚
â”‚          // 10.3 è¯»å–ç¼“å†²åŒº                                        â”‚
â”‚          ringbuffer_readbuf(&handle->devices[cpu],                â”‚
â”‚                             &buf, &len);                          â”‚
â”‚                                                                    â”‚
â”‚          // 10.4 è§£æäº‹ä»¶å¤´                                        â”‚
â”‚          scap_evt *evt = (scap_evt *)buf;                         â”‚
â”‚          // evt->ts, evt->tid, evt->type, evt->nparams            â”‚
â”‚                                                                    â”‚
â”‚          // 10.5 æŒ‰æ—¶é—´æˆ³æ’åºï¼ˆå¤š CPU äº‹ä»¶å½’å¹¶ï¼‰                   â”‚
â”‚          insert_into_event_queue(handle, evt);                    â”‚
â”‚      }                                                             â”‚
â”‚                                                                    â”‚
â”‚      // 10.6 è¿”å›æœ€æ—©çš„äº‹ä»¶                                        â”‚
â”‚      *pevent = pop_earliest_event(handle);                        â”‚
â”‚                                                                    â”‚
â”‚      // 10.7 æ›´æ–° tail æŒ‡é’ˆï¼ˆé€šçŸ¥å†…æ ¸å¯ä»¥å¤ç”¨ç©ºé—´ï¼‰                â”‚
â”‚      handle->devices[cpu].m_buffer_info->tail += (*pevent)->len;  â”‚
â”‚                                                                    â”‚
â”‚      return SCAP_SUCCESS;                                         â”‚
â”‚  }                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  11. äº‹ä»¶ä¼ é€’ç»™ Falco è§„åˆ™å¼•æ“                                     â”‚
â”‚      - libsinsp è§£æäº‹ä»¶ï¼ˆè§£æè¿›ç¨‹ä¿¡æ¯ã€æ–‡ä»¶è·¯å¾„ç­‰ï¼‰               â”‚
â”‚      - Falco åº”ç”¨è§„åˆ™åŒ¹é…                                          â”‚
â”‚      - æ£€æµ‹åˆ°å¼‚å¸¸è¡Œä¸ºç”Ÿæˆå‘Šè­¦                                      â”‚
â”‚                                                                    â”‚
â”‚      ç¤ºä¾‹è§„åˆ™ï¼š                                                     â”‚
â”‚      - rule: Read sensitive file                                  â”‚
â”‚        condition: open_read and sensitive_files                   â”‚
â”‚        output: "Sensitive file opened (file=%fd.name)"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2.4 ç³»ç»Ÿè°ƒç”¨æ‹¦æˆªçš„å®ç°æœºåˆ¶å¯¹æ¯”

### Tracepoint vs Kprobe vs eBPF

| æœºåˆ¶ | Falcoä½¿ç”¨ | åŸç† | å†…æ ¸æ¥å£ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|-----------|------|----------|------|------|
| **Tracepoint** | âœ… Kmod | å†…æ ¸é¢„å®šä¹‰çš„ç¨³å®šé’©å­ç‚¹ | `trace_sys_enter/exit` | ç¨³å®šã€ABI ä¿è¯ã€é«˜æ€§èƒ½ | ä½ç½®å›ºå®šï¼Œä¸çµæ´» |
| **Raw Tracepoint** | âœ… Legacy BPF | BPF åŸå§‹ tracepoint | `SEC("raw_tracepoints/")` | ä½å¼€é”€ï¼Œç›´æ¥è®¿é—® | éœ€è¦è§£æåŸå§‹å‚æ•° |
| **BTF Tracepoint** | âœ… Modern BPF | BPFç±»å‹æ ¼å¼ï¼Œç±»å‹å®‰å…¨ | `SEC("tp_btf/")` | æœ€ç°ä»£ã€CO-REã€ç±»å‹å®‰å…¨ | éœ€è¦å†…æ ¸ 5.8+ |
| **Kprobe** | âŒ | åŠ¨æ€æ’æ¡©ä»»æ„å†…æ ¸å‡½æ•° | `kprobe_register()` | æœ€çµæ´»ï¼Œä»»æ„ä½ç½® | ä¸ç¨³å®šï¼ˆå‡½æ•°å¯èƒ½æ”¹åï¼‰ |

### Tracepoint æ³¨å†Œå¯¹æ¯”

#### å†…æ ¸æ¨¡å—æ–¹å¼

```c
// ä»£ç ä½ç½®ï¼šdriver/main.c

// 1. å®šä¹‰ tracepoint é’©å­å‡½æ•°
TRACEPOINT_PROBE(syscall_exit_probe, void *__data,
                 struct pt_regs *regs, long ret) {
    // å¤„ç†ç³»ç»Ÿè°ƒç”¨é€€å‡ºäº‹ä»¶
    long id = syscall_get_nr(current, regs);
    // ... å¤„ç†é€»è¾‘
}

// 2. æŸ¥æ‰¾ tracepoint ç»“æ„
static struct tracepoint *tp_sys_exit = NULL;

static void find_tracepoint_callback(
    struct tracepoint *tp, void *priv) {
    if (strcmp(tp->name, "sys_exit") == 0) {
        tp_sys_exit = tp;
    }
}

// 3. æ¨¡å—åˆå§‹åŒ–æ—¶æ³¨å†Œ
static int ppm_init(void) {
    // æŸ¥æ‰¾ tracepoint
    for_each_kernel_tracepoint(find_tracepoint_callback, NULL);

    // æ³¨å†Œå›è°ƒå‡½æ•°
    ret = tracepoint_probe_register(
        tp_sys_exit,
        syscall_exit_probe,
        NULL);  // ç§æœ‰æ•°æ®

    return 0;
}

// 4. æ¨¡å—å¸è½½æ—¶æ³¨é”€
static void ppm_exit(void) {
    tracepoint_probe_unregister(
        tp_sys_exit,
        syscall_exit_probe,
        NULL);
}
```

#### Legacy BPF æ–¹å¼

```c
// ä»£ç ä½ç½®ï¼šdriver/bpf/probe.c:113

// BPF ç¨‹åºé€šè¿‡ section åç§°è‡ªåŠ¨ç»‘å®š
BPF_PROBE("raw_syscalls/", sys_exit, sys_exit_args) {
    // è¿™ä¸ª section åç§°ï¼š
    // - "raw_syscalls/" = tracepoint ç±»åˆ«
    // - "sys_exit" = tracepoint åç§°
    // åŠ è½½å™¨ä¼šè‡ªåŠ¨å°†æ­¤ç¨‹åºé™„åŠ åˆ° tracepoint

    long id = bpf_syscall_get_nr(ctx);
    // ... å¤„ç†é€»è¾‘
    return 0;
}

// ç”¨æˆ·æ€åŠ è½½ä»£ç ï¼ˆlibscap/engine/bpf/scap_bpf.cï¼‰ï¼š
int load_bpf_program(struct bpf_engine *handle) {
    // 1. æ‰“å¼€ BPF å¯¹è±¡æ–‡ä»¶
    struct bpf_object *obj = bpf_object__open("probe.o");

    // 2. åŠ è½½æ‰€æœ‰ç¨‹åº
    bpf_object__load(obj);

    // 3. æŸ¥æ‰¾ç¨‹åº
    struct bpf_program *prog =
        bpf_object__find_program_by_name(obj, "sys_exit");

    // 4. é™„åŠ åˆ° tracepointï¼ˆè‡ªåŠ¨æ ¹æ® section åç§°ï¼‰
    struct bpf_link *link =
        bpf_program__attach(prog);

    return 0;
}
```

#### Modern BPF æ–¹å¼

```c
// ä»£ç ä½ç½®ï¼šmodern_bpf/programs/attached/dispatchers/syscall_exit.bpf.c

// SEC("tp_btf/sys_exit") è¡¨ç¤ºä½¿ç”¨ BTFï¼ˆBPF Type Formatï¼‰
// ä¼˜ç‚¹ï¼š
// - ç±»å‹å®‰å…¨ï¼šç¼–è¯‘å™¨æ£€æŸ¥å‚æ•°ç±»å‹
// - å‚æ•°è‡ªåŠ¨ç»‘å®šï¼šBPF_PROG å®å¤„ç†
// - CO-REï¼šä¸€æ¬¡ç¼–è¯‘åˆ°å¤„è¿è¡Œ

SEC("tp_btf/sys_exit")
int BPF_PROG(sys_exit_dispatcher,
             struct pt_regs *regs,  // è‡ªåŠ¨ä» tracepoint æå–
             long ret) {            // ç³»ç»Ÿè°ƒç”¨è¿”å›å€¼

    // BPF_PROG å®å±•å¼€åè‡ªåŠ¨å¤„ç†å‚æ•°ç»‘å®š
    // ä¸éœ€è¦æ‰‹åŠ¨ä» ctx æå–å‚æ•°

    long id = extract__syscall_id(regs);

    // Tail call åˆ°å…·ä½“å¤„ç†ç¨‹åº
    bpf_tail_call(ctx, &tail_call_table, id);

    return 0;
}

// ç”¨æˆ·æ€åŠ è½½ï¼ˆlibbpf skeletonï¼‰
#include "syscall_exit.skel.h"

int load_modern_bpf(void) {
    // 1. æ‰“å¼€ skeleton
    struct syscall_exit_bpf *skel =
        syscall_exit_bpf__open();

    // 2. åŠ è½½å’ŒéªŒè¯
    syscall_exit_bpf__load(skel);

    // 3. è‡ªåŠ¨é™„åŠ æ‰€æœ‰ç¨‹åº
    syscall_exit_bpf__attach(skel);

    return 0;
}
```

---

## å…³é”®ä»£ç ä½ç½®é€ŸæŸ¥è¡¨

| åŠŸèƒ½ | å†…æ ¸æ¨¡å— | Legacy BPF | Modern BPF | ç”¨æˆ·æ€ |
|------|---------|-----------|-----------|--------|
| **ä¸»å…¥å£** | `driver/main.c` | `driver/bpf/probe.c` | `modern_bpf/programs/attached/dispatchers/` | `libscap/scap.c` |
| **Filler** | `driver/ppm_fillers.c` | `driver/bpf/fillers.h` | `modern_bpf/programs/tail_called/events/` | - |
| **äº‹ä»¶è¡¨** | `driver/event_table.c` | `driver/bpf/maps.h` (Map) | `modern_bpf/maps/` | `libscap/scap.h` |
| **ç¼“å†²åŒº** | `driver/ppm_ringbuffer.h` | `driver/bpf/ring_helpers.h` | `modern_bpf/helpers/store/` | `libscap/ringbuffer/` |
| **æ•°æ®ç»“æ„** | `driver/ppm_events_public.h` | åŒå·¦ | åŒå·¦ | åŒå·¦ |

---

## ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº† Falco é©±åŠ¨çš„ä»£ç ç»„ç»‡ç»“æ„ã€‚æ¥ä¸‹æ¥ï¼š

ğŸ‘‰ [ç¬¬ä¸‰ç« ï¼šæ ¸å¿ƒåŠŸèƒ½æ·±å…¥](./03-core-features.md) - å­¦ä¹ ç³»ç»Ÿè°ƒç”¨é’©å­ã€è¿›ç¨‹ä¸Šä¸‹æ–‡ã€ç½‘ç»œäº‹ä»¶ç­‰æ ¸å¿ƒåŠŸèƒ½çš„å®ç°

---

**å®è·µå»ºè®®ï¼š**

1. **å…‹éš†ä»£ç ä»“åº“**ï¼š
   ```bash
   git clone https://github.com/falcosecurity/libs.git
   cd libs/driver
   ```

2. **æ¢ç´¢å…³é”®æ–‡ä»¶**ï¼š
   - å…ˆé˜…è¯» `ppm_events_public.h` äº†è§£äº‹ä»¶å®šä¹‰
   - å†é˜…è¯» `event_table.c` äº†è§£ç³»ç»Ÿè°ƒç”¨æ˜ å°„
   - æœ€åé˜…è¯» `ppm_fillers.c` çš„å‡ ä¸ª filler å‡½æ•°ç¤ºä¾‹

3. **ä½¿ç”¨ grep æŸ¥æ‰¾**ï¼š
   ```bash
   # æŸ¥æ‰¾æ‰€æœ‰ filler å‡½æ•°
   grep -n "^int f_sys_" driver/ppm_fillers.c

   # æŸ¥æ‰¾äº‹ä»¶ç±»å‹å®šä¹‰
   grep "PPME_SYSCALL" driver/ppm_events_public.h
   ```

4. **ç»˜åˆ¶æ€ç»´å¯¼å›¾**ï¼šå°†ä»£ç ç»“æ„ç”»æˆæ€ç»´å¯¼å›¾ï¼ŒåŠ æ·±ç†è§£
